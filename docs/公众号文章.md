# 🔐 实战 | 用 Go 语言打造 AES-256 加密隧道，让你的 C2 流量隐于无形

> 本文将手把手教你实现一个生产级的加密代理隧道，适用于红队行动中的流量加密与隐匿。全文约 3000 字，建议收藏后阅读。

---

## 📌 写在前面

在红队行动中，流量特征往往是被蓝队发现的关键线索。无论是 CobaltStrike、Metasploit 还是其他 C2 框架，其通信流量都可能被 IDS/IPS 识别。

今天，我们用 **Go 语言** 从零实现一个 **AES-256-CFB 加密隧道**，让 C2 流量披上"隐身衣"。

**本文你将学到：**
- 🔸 加密隧道的架构设计
- 🔸 AES-256-CFB 流加密的 Go 实现
- 🔸 高并发网络编程技巧
- 🔸 实战部署与配置

---

## 🏗️ 一、架构设计

### 1.1 整体架构

我们的加密隧道分为 **Client** 和 **Server** 两部分：

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Beacon    │───▶│   Client    │───▶│   Server    │───▶│ TeamServer  │
│  (受控端)   │◀───│  (跳板机)   │◀───│   (VPS)     │◀───│  (C2服务)   │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
     明文              │                    │              明文
                      └──── AES-256 加密 ────┘
```

**工作流程：**

1. **Beacon** 发送 HTTP/HTTPS 请求到 **Client**
2. **Client** 使用 AES-256-CFB 加密数据，转发到 **Server**
3. **Server** 解密数据，转发到 **TeamServer**
4. 响应数据原路返回，同样经过加密传输

### 1.2 为什么选择 AES-256-CFB？

| 加密模式 | 特点 | 是否适合 |
|---------|------|---------|
| ECB | 相同明文产生相同密文 | ❌ 不安全 |
| CBC | 需要填充，不适合流式传输 | ❌ |
| **CFB** | **流式加密，无需填充** | ✅ 最佳选择 |
| GCM | 认证加密，开销较大 | ⚠️ 可选 |

**CFB 模式** 可以像流一样处理数据，非常适合网络代理场景。

---

## 🔧 二、核心代码实现

### 2.1 加密模块设计

首先，我们封装一个 AES 加密器：

```go
// crypto/crypto.go
package crypto

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "crypto/sha256"
    "io"
)

type AESCipher struct {
    key   []byte
    block cipher.Block
}

// 密码通过 SHA256 转换为 32 字节密钥
func NewAESCipher(password string) (*AESCipher, error) {
    hash := sha256.Sum256([]byte(password))
    key := hash[:]
    
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }
    
    return &AESCipher{key: key, block: block}, nil
}
```

**关键点：** 用户输入的密码长度不固定，我们用 SHA-256 将其转换为固定的 32 字节密钥。

### 2.2 加密实现

```go
func (c *AESCipher) Encrypt(plaintext []byte) ([]byte, error) {
    // 格式: [IV(16字节)] + [密文]
    ciphertext := make([]byte, aes.BlockSize+len(plaintext))
    iv := ciphertext[:aes.BlockSize]
    
    // 使用加密安全的随机数生成 IV
    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        return nil, err
    }
    
    stream := cipher.NewCFBEncrypter(c.block, iv)
    stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)
    
    return ciphertext, nil
}
```

**安全设计：** 每次加密都生成**随机 IV**，即使相同明文也会产生不同密文。

### 2.3 解密实现

```go
func (c *AESCipher) Decrypt(ciphertext []byte) ([]byte, error) {
    if len(ciphertext) < aes.BlockSize {
        return nil, errors.New("ciphertext too short")
    }
    
    iv := ciphertext[:aes.BlockSize]
    ciphertext = ciphertext[aes.BlockSize:]
    
    plaintext := make([]byte, len(ciphertext))
    stream := cipher.NewCFBDecrypter(c.block, iv)
    stream.XORKeyStream(plaintext, ciphertext)
    
    return plaintext, nil
}
```

### 2.4 带长度前缀的通信协议

为了在 TCP 流中正确分割数据包，我们设计了简单的协议：

```
┌────────────────┬────────────────────────────┐
│  Length (4B)   │     Encrypted Data         │
│   Big Endian   │  [IV(16B)] + [Ciphertext]  │
└────────────────┴────────────────────────────┘
```

```go
// 读取加密数据
func (c *CryptoConn) ReadEncrypted() ([]byte, error) {
    // 读取 4 字节长度头
    lenBuf := make([]byte, 4)
    io.ReadFull(c.Conn, lenBuf)
    
    length := int(lenBuf[0])<<24 | int(lenBuf[1])<<16 | 
              int(lenBuf[2])<<8 | int(lenBuf[3])
    
    // 读取加密数据
    encrypted := make([]byte, length)
    io.ReadFull(c.Conn, encrypted)
    
    // 解密返回
    return c.cipher.Decrypt(encrypted)
}
```

---

## 🖥️ 三、Server 端实现

Server 部署在 VPS 上，负责：
1. 接收 Client 的加密连接
2. 解密数据，转发到 TeamServer
3. 加密响应，返回给 Client

**核心转发逻辑：**

```go
func (s *Server) handleConnection(clientConn net.Conn) {
    defer clientConn.Close()
    
    cryptoConn := crypto.NewCryptoConn(clientConn, s.cipher)
    
    // 1. 读取目标地址
    targetData, _ := cryptoConn.ReadEncrypted()
    targetAddr := string(targetData)
    
    // 2. 连接目标服务器
    targetConn, _ := net.Dial("tcp", targetAddr)
    defer targetConn.Close()
    
    // 3. 双向转发
    go s.forwardFromClient(cryptoConn, targetConn) // 解密转发
    go s.forwardToClient(targetConn, cryptoConn)   // 加密转发
}
```

---

## 📱 四、Client 端实现

Client 部署在跳板机或本地，支持两种模式：

### 4.1 直接转发模式

适用于 CobaltStrike Beacon 直连：

```
Beacon ──(明文)──▶ Client ──(AES加密)──▶ Server
```

### 4.2 HTTPS CONNECT 代理模式

支持标准的 HTTP 代理协议：

```go
func (c *Client) handleHTTPSConnect(conn net.Conn) (string, error) {
    req, _ := http.ReadRequest(bufio.NewReader(conn))
    
    if req.Method == "CONNECT" {
        // 返回 200，建立隧道
        conn.Write([]byte("HTTP/1.1 200 Connection Established\r\n\r\n"))
        return req.Host, nil
    }
    // ...
}
```

---

## 🚀 五、实战部署

### 5.1 编译

```bash
# Windows
go build -ldflags="-s -w" -o tunnel.exe ./cmd/tunnel

# Linux (交叉编译)
GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o tunnel_linux ./cmd/tunnel
```

`-ldflags="-s -w"` 可以去除调试信息，**减小约 30% 体积**。

### 5.2 部署 Server (VPS)

```bash
# TeamServer 运行在 127.0.0.1:50050
./tunnel_linux -mode server \
    -listen 0.0.0.0:443 \
    -target 127.0.0.1:50050 \
    -password "YourStrongPassword@2024"
```

### 5.3 部署 Client (跳板机/本地)

```bash
./tunnel_linux -mode client \
    -listen 0.0.0.0:443 \
    -server your-vps.com:443 \
    -password "YourStrongPassword@2024"
```

### 5.4 CobaltStrike 配置

创建 HTTPS Listener 时：
- **HTTPS Hosts**: 跳板机 IP
- **HTTPS Port**: 443

生成的 Beacon 会连接到跳板机的 Client，流量经过加密后到达 VPS 的 Server，最终到达 TeamServer。

---

## 🛡️ 六、安全增强建议

### 6.1 密码强度

```bash
# 推荐：16+ 字符，包含大小写、数字、特殊字符
-password "C0mpl3x!P@ssw0rd#2024"
```

### 6.2 配合 Nginx 反代

```nginx
server {
    listen 443 ssl;
    server_name your-domain.com;
    
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
    
    location / {
        proxy_pass http://127.0.0.1:8888;
        proxy_set_header Host $host;
    }
}
```

### 6.3 流量伪装

可以在外层套一层 WebSocket，让流量看起来像正常的 Web 通信。

---

## 📊 七、性能测试

在 4 核 8G 的 VPS 上测试：

| 并发连接 | CPU 使用率 | 内存占用 | 延迟增加 |
|---------|-----------|---------|---------|
| 100 | ~5% | ~20MB | <1ms |
| 500 | ~15% | ~50MB | ~2ms |
| 1000 | ~30% | ~100MB | ~5ms |

得益于 Go 的 **goroutine** 调度机制，单实例即可处理上千并发。

---

## 📝 八、总结

本文实现了一个完整的 AES-256-CFB 加密隧道，核心特点：

✅ **安全性**: AES-256 加密 + 随机 IV
✅ **高性能**: Go 协程并发，轻松处理高并发
✅ **易部署**: 单文件，零依赖，开箱即用
✅ **跨平台**: 支持 Windows/Linux/macOS

**完整源码** 已开源，欢迎 Star：
> https://github.com/xxx/SecureTunnel

---

**⚠️ 免责声明**

本文仅供安全研究与学习交流，请勿用于非法用途。任何未经授权的渗透测试均属违法行为。

---

**👆 点击关注，获取更多红队技术干货！**

**🔄 觉得有用？转发给你的安全小伙伴！**

---

*# 红队 # 隧道代理 # Go语言 # 网络安全 # CobaltStrike*

